/*
	requires spl MITM and ro!ease_nro_restriction = 0x1
*/

var utils = require("./utils")

module.exports = (res) => {
	if(!sc.sdb) {
		throw new Error("requires spl mitm. try `enable sdbcore`");
	}
	if(sc.version !== "3.0.0") {
		throw new Error("requires 3.0.0");
	}
	
	var nrr = new ArrayBuffer(0x1000);
	var nrru32 = new Uint32Array(nrr);
	nrru32[0] = 0x3052524E; // NRR0
	nrru32[(0x338 >> 2) + 0] = 0x1000; // Size
	nrru32[(0x340 >> 2) + 0] = 0x350; // Hash offset
	nrru32[(0x340 >> 2) + 1] = 0x1; // Hash count
	
	while(res.length & 0xFFF)
		res.push(0);
	var u8 = new Uint8Array(res);
	var u32 = new Uint32Array(u8.buffer);

	var nroSize = u32[0x18 >> 2];
	var bssSize = u32[0x38 >> 2];
	var mod0Offset = u32[1];
	var dynamicOffset = mod0Offset + u32[(mod0Offset >> 2) + 1];

	utils.log("dynamic offset: 0x" + dynamicOffset.toString(16));

	crypto.subtle.digest("SHA-256", u8.buffer).then((hash) => {
		var nrrhashu8 = new Uint8Array(nrr, 0x350, 32);
		var hashu8 = new Uint8Array(hash);
		nrrhashu8.set(hashu8);
		
		sc.getService("ldr:ro", (ldrro) => {
			sc.ipcMsg(4).datau64(0).sendPid().copyHandle(0xffff8001).sendTo(ldrro).assertOk();
			sc.ipcMsg(2).datau64(0, sc.getArrayBufferAddr(nrr), nrr.byteLength).sendPid().sendTo(ldrro).show();
			
			var nrobase = sc.malloc(u8.length + bssSize + 0xfff);
			if(nrobase[0] & 0xFFF)
				nrobase[0] = ((nrobase[0] & 0xFFFFF000) + 0x1000) >>> 0;
			
			sc.memcpy(nrobase, u8, u8.byteLength);
			
			sc.svcNroBase = sc.ipcMsg(0).datau64(0, nrobase, nroSize, utils.add2(nrobase, nroSize), bssSize).sendPid().sendTo(ldrro).assertOk().data;
			
			utils.log('NRO loaded at ' + utils.paddr(sc.svcNroBase));
			utils.log("relocating...");

			sc.memview(sc.svcNroBase, nroSize, (lab) => {
				var lu32 = new Uint32Array(lab);
				var dynamicIndex = 0;
				var relaOffset;
				var relaSize;
				var relaEnt;
				var relaCount;
				while(true) {
					var d_tag = lu32[(dynamicOffset + dynamicIndex * 16) >> 2];
					var d_val = [
						lu32[((dynamicOffset + dynamicIndex * 16) >> 2) + 2],
						lu32[((dynamicOffset + dynamicIndex * 16) >> 2) + 3]]
					
					utils.log("dynamic tag " + d_tag);
					utils.log("dynamic val " + utils.paddr(d_val));
					if(d_tag == 0) { break; }
					switch(d_tag) {
					case 7: // DT_RELA
						relaOffset = utils.trunc32(d_val);
						break;
					case 8: // DT_RELASZ
						relaSize = utils.trunc32(d_val);
						break;
					case 9: // DT_RELAENT
						relaEnt = utils.trunc32(d_val);
						break;
					case 16: // DT_SYMBOLIC
						break;
					case 0x6ffffff9: // DT_RELACOUNT
						relaCount = utils.trunc32(d_val);
						break;
					}
					dynamicIndex++;
				}
				
				utils.log("rela offset " + relaOffset);
				utils.log("rela count " + relaCount);
				utils.log("r_offset 1st: " + lu32[relaOffset >> 2]);
				
				for(var i = 0; i < relaCount; i++) {
					var r_offset = [
						lu32[((relaOffset + (i*0x18)) >> 2) + 0],
						lu32[((relaOffset + (i*0x18)) >> 2) + 1]];
					var r_reloc_type = lu32[((relaOffset + (i*0x18)) >> 2) + 2];
					var r_symbol = lu32[((relaOffset + (i*0x18)) >> 2) + 3];
					var r_addend = [
						lu32[((relaOffset + (i*0x18)) >> 2) + 4],
						lu32[((relaOffset + (i*0x18)) >> 2) + 5]];
					
					switch(r_reloc_type) {
					case 0x403: // R_AARCH64_RELATIVE
						if(r_symbol != 0) {
							throw new Error("R_AARCH64_RELATIVE with symbol NYI");
						}
						var result = utils.add2(sc.svcNroBase, r_addend);
						sc.write8(result, utils.add2(sc.svcNroBase, r_offset));
						break;
					default:
						throw new Error("unsupported relocation");
					}
				}
			});

			utils.log("finished relocations. closing sm and jumping...");
			sc.svcCloseHandle(sc.smHandle).assertOk();
			sc.smHandle = undefined;
			utils.log("returned " + utils.paddr(sc.call(utils.add2(sc.svcNroBase, 0x80), [])));
			
			utils.log("log buffer: " + utils.paddr(sc.read8(utils.add2(sc.svcNroBase, mod0Offset + 0x1C))));
			var logBufferAddr = sc.read8(utils.add2(sc.svcNroBase, mod0Offset + 0x1C));
			var logLengthAddr = sc.read8(utils.add2(sc.svcNroBase, mod0Offset + 0x24));

			utils.log("LOG:");
			sc.memview(logBufferAddr, sc.read4(logLengthAddr), (logab) => {
				utils.log(utils.u8a2nullstr(new Uint8Array(logab)));
			});
		});
	}).catch((e) => {
		utils.log("error in then()");
		window.onerror(e.message, null, e.line, null, e);
	});
};
